在学习如何写 Web3 代码之前，我们需要花一些时间，理解我提炼出来的最小原子基础知识点，毕竟区块链这个技术体系，方方面面的知识太多了，我们不需要去关注那么多，而是以脚本的视角来明确最小原子基础知识点。

网络，就涉及到通信，通信就涉及到数据的交换格式，而 JSON-RPC 就是所有执行客户端实现的标准方法集合，而我们写的代码，实际上就是在通过与网络的通信来交换数据，简单来说，我们可以理解为读写模式，使用一套 JSON 描述我们的行为，将这段 JSON 广播出去，拥有执行客户端的人根据这段 JSON 来完成读取或写入的操作。

[https://github.com/ethereum/execution-apis](https://github.com/ethereum/execution-apis)

我们需要了解两个定语：Provider 和 Signer ，同时忽略复杂的加密概念，在我们与合约交互时用语言来描述，它的行为，就是，如果你只是读取，使用 Provider ，直接调用 JSON-RPC APIs 即可 ，这些方法在前端的库中有对应的实现，但它的背后，实际是将你要调用的方法，用 JSON 来描述，将这一段 JSON 广播了出去。

```json
{
  "id":1
  "jsonrpc":"2.0"
  "method":"debug_getBadBlocks"
  "params":[]
}
```

```json
{
  "id":1
  "jsonrpc":"2.0"
  "result":[]
}
```

这些读取，是不需要验证你的控制权的。

你可以想象一下，我们在推特上写内容，就好比，我们通过 JSON-RPC 将内容发送出去，写入推特这个平台（假装一下它是以太坊区块链），但如果不能验证你是你，那岂不是乱套了？任何人都可以把内容发送到你的推文里，正常来说只有验证了你是你，你才能把内容发送到你的推文里。

Signer 干的就是这个事情，这里牵扯到一个非对称加密的概念（我觉得你可以忽略，只需简单的理解），在生成钱包的时候有两把钥匙，一把钥匙是公开的，一把钥匙仅自己有，有一天我们用仅自己有的钥匙对内容进行了签名，然后将签名广播出去了，这个时候任何知道你公开钥匙的人（客户端），都可以对这个签名进行验证，证明这个内容是不是你的钥匙签的。

这就解决了，你是你的问题，同时将你签名的这一段 JSON 描述广播了出去。

[https://ethereum.github.io/execution-apis/api-documentation/](https://ethereum.github.io/execution-apis/api-documentation/)

对于写脚本，我们要理解的就是这个，接下来，你才能知道，怎么玩。